# EN
[Writing a Tiny x86 Bootloader](https://www.joe-bergeron.com/posts/Writing%20a%20Tiny%20x86%20Bootloader/)

# CN
## 编写一个微小的x86引导程序
##### 2016年12月27日

本文中的所有代码/文件都可以在我的[Github](https://github.com/Jophish/tiny-bootstrap)上找到。

编辑：在[good people on Hacker News](https://news.ycombinator.com/item?id=13268781)上的一些讨论后，已经明确，在16位实模式下，最好使用2字节寄存器bp和sp，而不是4字节的esb和esp。文章和代码已经进行了更新，以反映这一点。

___

可能是因为被困在家里，没有休息时可做的事情，或者可能是出于对低级系统设计的真正兴趣，但我已经决定自己学习有关操作系统实施的更多知识，首先从引导程序开始。因此，让我们开始吧。虽然在网上已经存在各种其他地方的所有这些信息，但通过教授来学习无疑是更好的方法，对吧？无论如何，这篇文章应该作为对引导程序到底是什么以及如何实现一个相对简单引导程序的入门指南（与像[GRUB](https://en.wikipedia.org/wiki/GNU_GRUB)这样的庞然大物相比，它显然是一个独立的小型操作系统）。

### 什么是引导程序（Bootloader）？

当计算机启动时，从无到有，使操作系统正常运行涉及多个步骤。在x86 PC上，首先发生的是BIOS的操作。我们将避免讨论BIOS工作的细节，但以下是你需要知道的内容。当你打开计算机时，处理器会立刻查看物理地址0xFFFFFFF0以获取BIOS代码，通常存储在计算机中某个只读的ROM存储器中。然后，BIOS进行POST（电源自检），并搜索可接受的启动介质。如果BIOS认为某个驱动器是可引导的，那么它会将磁盘的前512字节，也就是引导扇区（boot sector），加载到内存地址0x007C00，并通过跳转指令将程序控制传递到这个地址，交给处理器来执行。

大多数现代BIOS程序都非常强大，例如，如果BIOS识别到几个具有适当引导扇区的驱动器，它将从具有最高预分配优先级的驱动器引导。这也是为什么大多数计算机默认从USB引导而不是硬盘引导，如果在启动时插入了可引导的USB驱动器的原因。

通常，引导扇区的代码的作用是加载存储在非易失性存储器的更大的“真正”操作系统。实际上，这是一个多步骤的过程。例如，主引导记录（Master Boot Record，MBR）是一个非常常见（尽管现在越来越被废弃）的分区存储设备引导扇区标准。由于引导扇区最多只能包含512字节的数据，因此MBR引导程序通常只是将控制传递给存储在磁盘的其他位置的更大的引导程序，而后者的任务是实际加载操作系统（链式加载）。但现在，我们不会过多关注这些；在这里的目标不是编写操作系统（将其留到另一篇文章中），而只是让计算机在我们选择的屏幕上输出一些内容。

还值得注意的是，执行权在处理器处于[实模式](https://en.wikipedia.org/wiki/Real_mode)而不是[保护模式](https://en.wikipedia.org/wiki/Protected_mode)下转交给引导代码，这意味着（除其他事项外）对你所熟悉和喜欢的操作系统的所有出色功能的访问都不可用。另一方面，这意味着我们可以直接访问BIOS的[中断调用](https://en.wikipedia.org/wiki/BIOS_interrupt_call)，提供了一些有趣的低级功能。

那么，从哪里开始呢？我决定在这个项目中使用[Netwide Assembler（NASM）](https://en.wikipedia.org/wiki/Netwide_Assembler)，这是一种相当广泛使用的汇编语言。至于测试，完全可以将编译后的汇编代码使用dd命令写入USB驱动器的前512字节，然后从中引导计算机，但这样的反馈速度不太快，对吧？[Bochs](https://en.wikipedia.org/wiki/Bochs)是一个不错的x86 IBM-PC兼容模拟器，具有许多有用的功能；我们将使用它进行测试。
